<template>
  <div class="new-node-container" ref="newNodeContainer" :style="{left: placement.x + 'px', top: placement.y + 'px' }">
    <div class="new-node-top" ref="newNodeTop">
      <input
        ref="input"
        v-model="userInput"
        type="text"
        placeholder="Type a concept"
        style="height: 2.5rem;"
        @keydown="onKeyDown"
      >
      <button
        v-if="userInput.length < 1"
        class="mx-2"
        style="border: none; background-color: white;"
        @click="$emit('show-custom-concept')"
      >
        <span style="color: #255DCC; font-size: 1.5rem;">
          <i class="fa fa-plus-circle"></i>
        </span>
      </button>
    </div>
    <dropdown-control
      v-if="userInput !== ''"
      class="suggestion-dropdown" :style="{left: dropdownLeftOffset + 'px', top: dropdownTopOffset + 'px'}">
      <template #content>
        <div class="tab-row">
          <div>
            Filter by: &nbsp;
          </div>
          <radio-button-group
            :buttons="[
              { label: 'Concepts', value: 'concepts' },
              { label: 'Datacubes', value: 'datacubes' }
            ]"
            :selected-button-value="activeTab"
            @button-clicked="setActive"
          />
        </div>

        <!-- datacubes -->
        <div
          v-if="activeTab === 'datacubes'"
          style="display: flex; flex-direction: row">
          <div class="left-column">
            <div
              v-for="(suggestion, index) in datacubeSuggestions"
              :key="suggestion.doc.variableName"
              class="dropdown-option"
              :class="{'focused': index === focusedSuggestionIndex}"
              @click="selectSuggestion(suggestion)"
              @mouseenter="mouseEnter(index)"
              @mouseleave="mouseLeave(index)"
            >
              {{ suggestion.doc.display_name }}
            </div>
          </div>
          <div
            v-if="datacubeSuggestions.length"
            class="right-column">
            <div style="font-weight: 600">{{ currentSuggestion.doc.display_name }}</div>
            <div style="color: #888">{{ currentSuggestion.doc.name }}</div>
            <div>&nbsp;</div>
            <div v-if="currentSuggestion.doc.period">
              {{ dateFormatter(currentSuggestion.doc.period.gte, temporalResolution === TemporalResolutionOption.Year ? 'YYYY' : 'MMMM YYYY') }} to {{ dateFormatter(currentSuggestion.doc.period.lte, temporalResolution === TemporalResolutionOption.Year ? 'YYYY' : 'MMMM YYYY') }}
            </div>
            <sparkline
              :data="sparklineData"
              :size="[220, 90]"
            />
            <div>{{ currentSuggestion.doc.description }}</div>
          </div>
        </div>

        <!-- concepts -->
        <div
          v-if="activeTab === 'concepts'"
          style="display: flex; flex-direction: row">
          <div class="left-column">
            <div
              v-for="(suggestion, index) in conceptSuggestions"
              :key="suggestion.doc.key"
              class="dropdown-option"
              :class="{'focused': index === focusedSuggestionIndex, 'light': !suggestion.hasEvidence}"
              @click="selectSuggestion(suggestion)"
              @mouseenter="mouseEnter(index)"
              @mouseleave="mouseLeave(index)"
            >
              {{ ontologyFormatter(suggestion.doc.key) }}
            </div>
          </div>
          <div
            v-if="conceptSuggestions.length"
            class="right-column">
            <div>
              <div
                v-for="(member, idx) in currentSuggestion.doc.members"
                :key="idx">
                <strong>{{ ontologyFormatter(member.label) }} </strong>
                <br>
                <div v-if="member.definition !== ''">
                  <small>Definition: {{ member.definition }} </small>
                </div>
                <div v-if="member.examples">
                  <small>
                    Examples:
                    <highlight-text
                      :text="member.examples.join(', ')"
                      :highlights="member.highlight ? member.highlight.examples: []"
                    />
                  </small>
                </div>
                <br>
              </div>
            </div>
          </div>
        </div>
      </template>
    </dropdown-control>
  </div>
</template>

<script lang="ts">
import _ from 'lodash';
import { computed, defineComponent, PropType, Ref, ref, toRefs, watch } from 'vue';
import { useStore } from 'vuex';
import API from '@/api/api';
import useOntologyFormatter from '@/services/composables/useOntologyFormatter';
import dateFormatter from '@/formatters/date-formatter';
import DropdownControl from '@/components/dropdown-control.vue';
import HighlightText from '@/components/widgets/highlight-text.vue';
import RadioButtonGroup from '../widgets/radio-button-group.vue';
import Sparkline from '@/components/widgets/charts/sparkline.vue';

import { ModelRun } from '@/types/ModelRun';
import { TimeseriesPoint } from '@/types/Timeseries';

import projectService from '@/services/project-service';
import datacubeService from '@/services/new-datacube-service';

import { AggregationOption, TemporalResolution, TemporalResolutionOption, TimeScale } from '@/types/Enums';
import { correctIncompleteData } from '@/utils/incomplete-data-detection';

const CONCEPT_SUGGESTION_COUNT = 10;

const getRunId = async (id: string): Promise<ModelRun> => {
  const run = await datacubeService.getDefaultModelRunMetadata(id);
  return run;
};

const getTimeseries = async (dataId: string, runId: string, feature: string,
  temporalRes: TemporalResolutionOption, agg: AggregationOption): Promise<TimeseriesPoint[]> => {
  const result = await API.get('maas/output/timeseries', {
    params: {
      data_id: dataId,
      run_id: runId,
      feature: feature,
      resolution: temporalRes,
      temporal_agg: agg,
      spatial_agg: agg,
      region_id: ''
    }
  });
  return result.data as TimeseriesPoint[];
};

export default defineComponent({
  name: 'NewNodeConceptSelect',
  components: {
    DropdownControl,
    HighlightText,
    RadioButtonGroup,
    Sparkline
  },
  props: {
    conceptsInCag: {
      type: Array,
      default: () => []
    },
    placement: {
      type: Object as PropType<{ x: number; y: number }>,
      default: () => ({ x: 0, y: 0 })
    },
    selectedTimeScale: {
      type: String as PropType<TimeScale>,
      required: true
    }
  },
  emits: [
    'suggestion-selected',
    'datacube-selected',
    'show-custom-concept'
  ],
  setup(props) {
    const { selectedTimeScale } = toRefs(props);

    const store = useStore();
    const userInput = ref('');
    const focusedSuggestionIndex = ref(0);
    const mouseOverIndex = ref(-1);
    const activeTab = ref('concepts');
    const conceptSuggestions = ref([]) as Ref<any[]>;
    const datacubeSuggestions = ref([]) as Ref<any[]>;
    const dropdownLeftOffset = ref(0);
    const dropdownTopOffset = ref(4); // prevent overlap with input box

    const timeseries = ref([]) as Ref<TimeseriesPoint[]>;
    const sparklineData = ref([]) as Ref<any[]>;

    const input = ref(null) as Ref<HTMLInputElement | null>;
    const newNodeTop = ref(null) as Ref<HTMLDivElement | null>;
    const newNodeContainer = ref(null) as Ref<HTMLDivElement | null>;

    const currentSuggestion = computed(() => {
      const idx = focusedSuggestionIndex.value;
      if (activeTab.value === 'concepts' && conceptSuggestions.value.length && idx > -1) {
        return conceptSuggestions.value[idx];
      }
      if (activeTab.value === 'datacubes' && datacubeSuggestions.value.length && idx > -1) {
        return datacubeSuggestions.value[idx];
      }
      return null;
    });

    const ontologyConcepts = computed(() => store.getters['app/ontologyConcepts']);
    const project = computed(() => store.getters['app/project']);

    watch(userInput, _.debounce(async () => {
      if (_.isEmpty(userInput.value)) {
        conceptSuggestions.value = [];
        datacubeSuggestions.value = [];
      } else {
        let results: any = null;
        results = await projectService.getConceptSuggestions(project.value, userInput.value);
        conceptSuggestions.value = results.splice(0, CONCEPT_SUGGESTION_COUNT);

        results = await datacubeService.getDatacubeSuggestions(userInput.value);
        datacubeSuggestions.value = results.splice(0, 5);
      }
    }, 300));

    const temporalResolution = ref(TemporalResolutionOption.Month);

    watch(currentSuggestion, async () => {
      if (currentSuggestion.value && activeTab.value === 'datacubes') {
        const doc = currentSuggestion.value.doc;

        // Figure out datacube or indicator
        let runId = 'indicator';
        if (doc.type !== 'indicator') {
          runId = (await getRunId(doc.data_id)).id;
        }

        //
        // Get the timeseries data
        //

        // convert time-scale value to TemporalResolutionOption
        if (selectedTimeScale.value === TimeScale.Months) {
          temporalResolution.value = TemporalResolutionOption.Month;
        }
        if (selectedTimeScale.value === TimeScale.Years) {
          temporalResolution.value = TemporalResolutionOption.Year;
        }
        const rawResolution = doc.raw_temporal_resolution ?? TemporalResolution.Other;
        const periodEndDate = new Date(doc.period?.lte ?? 0);
        const agg = AggregationOption.Mean;

        const result = await getTimeseries(doc.data_id, runId, doc.feature, temporalResolution.value, agg);
        const { points } = correctIncompleteData(result, rawResolution, temporalResolution.value, agg, periodEndDate);

        timeseries.value = points;
        sparklineData.value = [
          {
            name: 'test',
            series: result.map(d => d.value)
          }
        ];
      }
    });

    return {
      // element refs
      input,
      newNodeTop,
      newNodeContainer,

      // Reactive
      userInput,
      focusedSuggestionIndex,
      mouseOverIndex,
      activeTab,
      conceptSuggestions,
      datacubeSuggestions,
      dropdownLeftOffset,
      dropdownTopOffset,
      timeseries,
      sparklineData,
      temporalResolution,

      // Computed
      currentSuggestion,
      ontologyConcepts,
      project,

      dateFormatter,
      ontologyFormatter: useOntologyFormatter(),
      TemporalResolutionOption
    };
  },
  mounted() {
    this.calculateDropdownOffset();
    this.focusInput();
  },
  watch: {
    conceptSuggestions(n, o) {
      if (!_.isEqual(n, o)) {
        this.focusedSuggestionIndex = 0;
      }
    },
    activeTab(n, o) {
      if (!_.isEqual(n, o)) {
        this.focusedSuggestionIndex = 0;
      }
    }
  },
  methods: {
    // `delta` is 1 if moving down the list, -1 if moving up the list
    shiftFocus(delta: number) {
      let newFocusIndex = this.focusedSuggestionIndex + delta;
      if (newFocusIndex < 0) {
        newFocusIndex = this.conceptSuggestions.length - 1;
      } else if (newFocusIndex >= this.conceptSuggestions.length) {
        newFocusIndex = 0;
      }
      this.focusedSuggestionIndex = newFocusIndex;
    },
    onKeyDown(event: KeyboardEvent) {
      switch (event.key) {
        case 'Enter':
          this.onEnterPressed();
          break;
        case 'ArrowUp':
          this.shiftFocus(-1);
          event.preventDefault();
          break;
        case 'ArrowDown':
          this.shiftFocus(1);
          event.preventDefault();
          break;
      }
    },
    mouseEnter(index: number) {
      this.mouseOverIndex = index;
      this.focusedSuggestionIndex = index;
    },
    mouseLeave(index: number) {
      if (this.mouseOverIndex === index) {
        this.mouseOverIndex = -1;
      }
    },
    onEnterPressed() {
      if (this.conceptSuggestions.length === 0) return;
      const suggestion = this.conceptSuggestions[this.focusedSuggestionIndex];
      this.selectSuggestion(suggestion);
    },
    selectSuggestion(suggestion: any) {
      if (this.activeTab === 'concepts') {
        this.$emit('suggestion-selected', {
          concept: suggestion.doc.key,
          label: this.ontologyFormatter(suggestion.doc.key),
          shortName: '', // FIXME unused
          hasEvidence: false // FIXME unused
        });
      } else {
        const doc = this.currentSuggestion.doc;
        // The parameter part of node-parameter
        // FIXME: Need to find out what exactly we need, id or data_id, name or display_name ...
        this.$emit('datacube-selected', {
          id: doc.id,
          name: doc.display_name,
          unit: '',
          country: '',
          admin1: '',
          admin2: '',
          admin3: '',
          spatialAggregation: 'mean',
          temporalAggregation: 'mean',
          temporalResolution: this.temporalResolution,
          period: 12,
          timeseries: this.timeseries,
          min: _.min(this.timeseries.map(d => d.value)),
          max: _.max(this.timeseries.map(d => d.value))
        });
      }
      this.userInput = '';
    },
    focusInput() {
      if (this.input) {
        this.input.focus();
      }
    },
    calculateDropdownOffset() {
      // calculate if dropdown will collide with edge of screen and then translate if required
      if (this.newNodeTop && this.newNodeContainer) {
        const buffer = 100; // Discourage flipped orientation by allow bottom-boundary to exceed by buffer amount
        const inputBoundingBox = this.newNodeTop.getBoundingClientRect();
        const cagContainerBoundingBox = (this.newNodeContainer.parentNode as HTMLElement).getBoundingClientRect();

        const dropdownWidth = 0.45 * window.innerWidth; // convert vw to px
        const dropdownHeight = 330; // Match CSS

        if (inputBoundingBox.left + dropdownWidth > cagContainerBoundingBox.right) {
          this.dropdownLeftOffset = -dropdownWidth + inputBoundingBox.width;
        }
        if (inputBoundingBox.bottom + dropdownHeight > cagContainerBoundingBox.bottom + buffer) {
          this.dropdownTopOffset = -dropdownHeight - (inputBoundingBox.height + 4); // +4 to prevent overlap with input box
        }
      }
    },
    getConceptSuggestions() {
      const fetch = async () => {
        if (_.isEmpty(this.userInput)) {
          this.conceptSuggestions = [];
        } else {
          const conceptSuggestions = await projectService.getConceptSuggestions(this.project, this.userInput);
          this.conceptSuggestions = conceptSuggestions.splice(0, CONCEPT_SUGGESTION_COUNT);
        }
      };
      fetch();
    },
    getDatacubeSuggestions() {
      const fetch = async () => {
        if (_.isEmpty(this.userInput)) {
          this.datacubeSuggestions = [];
        } else {
          const datacubeSuggestions = await datacubeService.getDatacubeSuggestions(this.userInput);
          this.datacubeSuggestions = datacubeSuggestions.splice(0, 5);
        }
      };
      return fetch();
    },
    setActive(tab: string) {
      this.activeTab = tab;
    }
  }
});

</script>

<style lang="scss" scoped>
@import "~styles/variables.scss";

.new-node-container {
  position: absolute;
  top: 20px;
  left: 20px;
  display: inline-block;
  width: 15rem;
  height: 3rem;
  border: 2px solid $selected;
  border-radius: 4px;

  input {
    width: 100%;
    height: 100%;
    border: none;
    border-radius: 4px;
  }
}

.new-node-top {
  display: flex;
  flex-direction: row;
}

.suggestion-dropdown {
  width: 50vw;
}

.dropdown-option {
  position: relative;

  // Lighten default hover bg to emphasize focused item
  &:hover {
    background: #F8F8F8;
  }

  &.light {
    color: #6E6E6E;
  }

  &.focused {
    background: #EAEBEC; // `dropdown-control` hover colour

    // Blue bar along the left edge
    &::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 4px;
      background: $selected;
    }
  }
}

.tab-row {
  margin-left: 5px;
  margin-top: 5px;
  padding-bottom: 5px;
  display: flex;
  align-items: center;
  border-bottom: 1px solid #DDD;
}

.left-column {
  min-width: 280px;
  max-width: 280px;
  height: 290px;
  overflow-y: scroll;
}
.right-column {
  flex-grow: 1;
  padding: 8px;
  border-left: 1px solid #DDD;
  height: 290px;
  overflow-y: scroll;
}

</style>
